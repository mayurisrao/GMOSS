# -*- coding: utf-8 -*-
"""testinglog.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17r-mkzQi6E9hkTpCPjxdoF2UM2sJZLT3
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import astropy.coordinates as coord
import astropy.units as u
from astropy.io import ascii
from astropy.coordinates import SkyCoord
#import healpy as hp
sns.set()

x = [10,10**2,10**3,10**4]
plt.yscale("log")
plt.xscale("log")
plt.plot(x)

data1 = np.genfromtxt("map_22_r4_5deg_nested_galactic_Kelvin.txt")
data2 = np.genfromtxt("map_45_r4_5deg_nested_galactic_Kelvin.txt")
data3 = np.genfromtxt("map_150_r4_5deg_nested_galactic_Kelvin.txt")
data4 = np.genfromtxt("map_408_r4_5deg_nested_galactic_Kelvin.txt")
data5 = np.genfromtxt("map_1420_r4_5deg_nested_galactic_Kelvin.txt")
data6 = np.genfromtxt("map_23000_r4_5deg_nested_galactic_Kelvin.txt")
coods = np.genfromtxt("coods.txt", delimiter=" ", skip_header = 1)

pixel_number = int(input("Enter the pixel number from 1 to 3072: ")) - 1
print(pixel_number)

for_graphing = np.zeros(6)
len_of_data = len(data1)

for_graphing[0] = data1[pixel_number]
for_graphing[1] = data2[pixel_number]
for_graphing[2] = data3[pixel_number]
for_graphing[3] = data4[pixel_number]
for_graphing[4] = data5[pixel_number]
for_graphing[5] = data6[pixel_number]
plt.yscale("log")
plt.xscale("log")
plt.scatter([22,45,150,408,1420,23000],for_graphing)
#plt.yscale("log")
#plt.savefig("roughplot.png")
print(for_graphing)

coordinates = np.genfromtxt("coods.txt", delimiter=" ", skip_header = 1)
coordinates[0]
print(data1)

coordinates[:,0]

type(coordinates[:,1][0])

gal = SkyCoord(coordinates[:,0], coordinates[:,1], frame='galactic', unit=u.deg)

plt.subplot(111, projection='aitoff')
plt.grid(True)
plt.scatter(gal.l.wrap_at('180d').radian, gal.b.radian)

# Use the heatmap function from the seaborn package
sns.heatmap(coordinates,fmt="",cmap='RdYlGn',linewidths=0.30)

# Display the Pharma Sector Heatmap
plt.show()

!pip3 install healpy

import healpy as hp

NSIDE = 32
print(
    "Approximate resolution at NSIDE {} is {:.2} deg".format(
        NSIDE, hp.nside2resol(NSIDE, arcmin=True) / 60
    )
)

NPIX = hp.nside2npix(NSIDE)
print(NPIX)

m = np.arange(NPIX)
hp.mollview(m, title="Mollview image RING")
hp.graticule()

hp.projview(
    data2,
    coord=["G"],
    graticule=True,
    graticule_labels=True,
    unit="cbar label",
    xlabel="longitude",
    ylabel="latitude",
    cb_orientation="horizontal",
    projection_type="cart",
);

hp.projview(
    data1, coord=["G"], graticule=True, graticule_labels=True, projection_type="mollweide"
);

from scipy.optimize import curve_fit

# define the true objective function
def objective(x, a, b):
	return a * (x**2) + b

#choose input and output variables
x, y = [22,45,150,408,1420,23000], for_graphing

# curve fit
popt, _ = curve_fit(objective, x, y)

# summarize the parameter values
a, b = popt
print('y = %.5f * x + %.5f' % (a, b))
# plot input vs output
plt.yscale("log")
plt.xscale("log")
plt.scatter(x, y)

# define a sequence of inputs between the smallest and largest known inputs
x_line = np.arange(min(x), max(x), 1)
# calculate the output for the range
y_line = objective(x_line, a, b)
# create a line plot for the mapping function
plt.yscale("log")
plt.xscale("log")


plt.plot(x_line, y_line, '--', color='red')

#plt.yscale("log")
#plt.xscale("log")
plt.scatter(x, y)
plt.show()

hp.pixelfunc.ang2pix(16, coordinates[:,0], coordinates[:,1], nest=True, lonlat=True)

#doubled = [10**num for num in data2]

hp.mollview(data1)#,alpha = 0.3)









